# üîç Ejercicio 2: Security Vulnerability Assessment

## üìã Informaci√≥n del Ejercicio

**Duraci√≥n:** 45 minutos  
**Dificultad:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**Prerequisitos:** Aplicaci√≥n full-stack funcionando  
**Objetivos:** Realizar audit completo de seguridad y corregir vulnerabilidades

---

## üéØ Objetivos de Aprendizaje

Al completar este ejercicio, el estudiante ser√° capaz de:

- Realizar an√°lisis OWASP Top 10 en aplicaciones web
- Usar herramientas automatizadas de security scanning
- Identificar y corregir vulnerabilidades comunes
- Documentar findings y remediation plans
- Implementar security testing automatizado

---

## üìö Conceptos Clave

### **OWASP Top 10 2021**

1. **A01:2021 ‚Äì Broken Access Control**
2. **A02:2021 ‚Äì Cryptographic Failures**
3. **A03:2021 ‚Äì Injection**
4. **A04:2021 ‚Äì Insecure Design**
5. **A05:2021 ‚Äì Security Misconfiguration**
6. **A06:2021 ‚Äì Vulnerable and Outdated Components**
7. **A07:2021 ‚Äì Identification and Authentication Failures**
8. **A08:2021 ‚Äì Software and Data Integrity Failures**
9. **A09:2021 ‚Äì Security Logging and Monitoring Failures**
10. **A10:2021 ‚Äì Server-Side Request Forgery (SSRF)**

### **Security Assessment Metodolog√≠a**

- **Automated Scanning:** Herramientas automatizadas
- **Manual Testing:** Pruebas manuales espec√≠ficas
- **Code Review:** Revisi√≥n de c√≥digo fuente
- **Dependency Analysis:** An√°lisis de dependencias
- **Configuration Review:** Revisi√≥n de configuraciones

---

## üõ†Ô∏è Herramientas Utilizadas

- **npm audit** - Dependency vulnerability scanning
- **ESLint Security Plugin** - Static code analysis
- **OWASP ZAP** - Web application security testing
- **Snyk** - Vulnerability scanning
- **Bandit** - Python security linter (si aplica)

---

## üìù Instrucciones Paso a Paso

### **Paso 1: Setup de Herramientas de Security (10 minutos)**

#### **1.1 Instalar ESLint Security Plugin**

```bash
# Instalar eslint-plugin-security
pnpm install -D eslint-plugin-security

# Crear o actualizar .eslintrc.js
cat > .eslintrc.js << 'EOF'
module.exports = {
  env: {
    node: true,
    es2021: true,
  },
  extends: [
    'eslint:recommended',
    'plugin:security/recommended'
  ],
  plugins: ['security'],
  parserOptions: {
    ecmaVersion: 12,
    sourceType: 'module',
  },
  rules: {
    // Security rules
    'security/detect-buffer-noassert': 'error',
    'security/detect-child-process': 'warn',
    'security/detect-disable-mustache-escape': 'error',
    'security/detect-eval-with-expression': 'error',
    'security/detect-no-csrf-before-method-override': 'error',
    'security/detect-non-literal-fs-filename': 'warn',
    'security/detect-non-literal-regexp': 'error',
    'security/detect-non-literal-require': 'warn',
    'security/detect-object-injection': 'error',
    'security/detect-possible-timing-attacks': 'warn',
    'security/detect-pseudoRandomBytes': 'error',
    'security/detect-unsafe-regex': 'error'
  },
};
EOF
```

#### **1.2 Instalar Snyk para vulnerability scanning**

```bash
# Instalar Snyk globalmente
npm install -g snyk

# Autenticar con Snyk (requiere cuenta gratuita)
snyk auth

# Opcional: Instalar OWASP ZAP (herramienta GUI)
# Descargar desde: https://www.zaproxy.org/download/
```

#### **1.3 Crear script de security audit**

```bash
# Crear script de audit automatizado
cat > scripts/security-audit.sh << 'EOF'
#!/bin/bash

echo "üîç SECURITY AUDIT REPORT - $(date)"
echo "================================"

# 1. NPM Audit
echo -e "\nüì¶ NPM DEPENDENCY AUDIT:"
echo "-------------------------"
npm audit --audit-level=low

# 2. ESLint Security Check
echo -e "\nüîç ESLINT SECURITY ANALYSIS:"
echo "----------------------------"
npx eslint . --ext .js,.jsx --format=table

# 3. Snyk Vulnerability Test
echo -e "\nüõ°Ô∏è SNYK VULNERABILITY SCAN:"
echo "----------------------------"
snyk test

# 4. Check for common security files
echo -e "\nüìÑ SECURITY FILES CHECK:"
echo "-------------------------"
echo "Checking for security-related files..."

if [ -f ".env" ]; then
    echo "‚ö†Ô∏è  .env file found - ensure it's in .gitignore"
fi

if [ -f "package-lock.json" ] || [ -f "pnpm-lock.yaml" ]; then
    echo "‚úÖ Lock file present"
else
    echo "‚ùå No lock file found - dependencies not pinned"
fi

if [ -f ".gitignore" ]; then
    echo "‚úÖ .gitignore present"
else
    echo "‚ùå No .gitignore found"
fi

# 5. Check for hardcoded secrets
echo -e "\nüîê HARDCODED SECRETS CHECK:"
echo "---------------------------"
echo "Searching for potential secrets..."

# Check for common secret patterns
grep -r -i "password.*=" . --include="*.js" --include="*.jsx" --exclude-dir=node_modules
grep -r -i "secret.*=" . --include="*.js" --include="*.jsx" --exclude-dir=node_modules
grep -r -i "api.*key" . --include="*.js" --include="*.jsx" --exclude-dir=node_modules

echo -e "\n‚úÖ Security audit completed!"
EOF

chmod +x scripts/security-audit.sh
```

### **Paso 2: An√°lisis OWASP Top 10 (15 minutos)**

#### **2.1 Crear checklist OWASP Top 10**

```javascript
// security/owasp-checklist.js
const owaspChecklist = {
  'A01-Broken-Access-Control': {
    name: 'Broken Access Control',
    description: 'Failure to restrict what authenticated users can do',
    checkpoints: [
      {
        id: 'A01-01',
        description: 'Verify user authentication on protected routes',
        status: 'pending', // pending, pass, fail
        severity: 'high',
        test: async () => {
          // Test implementation
          return {
            passed: false,
            details: 'No authentication middleware found',
          };
        },
      },
      {
        id: 'A01-02',
        description: 'Check for proper authorization controls',
        status: 'pending',
        severity: 'high',
        test: async () => {
          // Test authorization
          return {
            passed: true,
            details: 'Authorization middleware implemented',
          };
        },
      },
      {
        id: 'A01-03',
        description: 'Verify CORS configuration',
        status: 'pending',
        severity: 'medium',
        test: async () => {
          // Test CORS settings
          return { passed: false, details: 'CORS allows all origins' };
        },
      },
    ],
  },

  'A02-Cryptographic-Failures': {
    name: 'Cryptographic Failures',
    description: 'Failures related to cryptography or lack thereof',
    checkpoints: [
      {
        id: 'A02-01',
        description: 'Verify password hashing implementation',
        status: 'pending',
        severity: 'critical',
        test: async () => {
          // Check password hashing
          return { passed: true, details: 'bcrypt implemented correctly' };
        },
      },
      {
        id: 'A02-02',
        description: 'Check for HTTPS enforcement',
        status: 'pending',
        severity: 'high',
        test: async () => {
          // Test HTTPS
          return { passed: false, details: 'No HTTPS redirect found' };
        },
      },
      {
        id: 'A02-03',
        description: 'Verify JWT secret security',
        status: 'pending',
        severity: 'critical',
        test: async () => {
          // Check JWT secret
          return { passed: false, details: 'JWT secret too short' };
        },
      },
    ],
  },

  'A03-Injection': {
    name: 'Injection',
    description: 'Data sent to interpreter as part of command or query',
    checkpoints: [
      {
        id: 'A03-01',
        description: 'Check for SQL injection vulnerabilities',
        status: 'pending',
        severity: 'critical',
        test: async () => {
          // Test for SQL injection
          return {
            passed: true,
            details: 'Using ORM with parameterized queries',
          };
        },
      },
      {
        id: 'A03-02',
        description: 'Verify input validation and sanitization',
        status: 'pending',
        severity: 'high',
        test: async () => {
          // Test input validation
          return {
            passed: false,
            details: 'Missing input validation on user endpoints',
          };
        },
      },
      {
        id: 'A03-03',
        description: 'Check for NoSQL injection vulnerabilities',
        status: 'pending',
        severity: 'high',
        test: async () => {
          // Test NoSQL injection
          return {
            passed: false,
            details: 'Direct object queries without sanitization',
          };
        },
      },
    ],
  },

  'A05-Security-Misconfiguration': {
    name: 'Security Misconfiguration',
    description: 'Missing security hardening across application stack',
    checkpoints: [
      {
        id: 'A05-01',
        description: 'Verify security headers implementation',
        status: 'pending',
        severity: 'medium',
        test: async () => {
          // Test security headers
          return { passed: false, details: 'Missing security headers' };
        },
      },
      {
        id: 'A05-02',
        description: 'Check error handling and information disclosure',
        status: 'pending',
        severity: 'medium',
        test: async () => {
          // Test error handling
          return {
            passed: false,
            details: 'Stack traces exposed in production',
          };
        },
      },
    ],
  },

  'A06-Vulnerable-Components': {
    name: 'Vulnerable and Outdated Components',
    description: 'Using components with known vulnerabilities',
    checkpoints: [
      {
        id: 'A06-01',
        description: 'Check for outdated dependencies',
        status: 'pending',
        severity: 'varies',
        test: async () => {
          // Test dependencies
          return { passed: false, details: 'Multiple outdated packages found' };
        },
      },
    ],
  },
};

module.exports = owaspChecklist;
```

#### **2.2 Implementar Security Assessment Runner**

```javascript
// security/security-assessor.js
const owaspChecklist = require('./owasp-checklist');
const fs = require('fs');
const path = require('path');

class SecurityAssessor {
  constructor() {
    this.results = {};
    this.findings = [];
  }

  async runFullAssessment() {
    console.log('üîç Starting comprehensive security assessment...\n');

    // Run OWASP Top 10 checks
    await this.runOWASPChecks();

    // Run automated scans
    await this.runAutomatedScans();

    // Generate report
    this.generateReport();

    return this.results;
  }

  async runOWASPChecks() {
    console.log('üìã Running OWASP Top 10 Assessment...');

    for (const [categoryId, category] of Object.entries(owaspChecklist)) {
      console.log(`\nTesting: ${category.name}`);

      const categoryResults = {
        name: category.name,
        description: category.description,
        checkpoints: [],
      };

      for (const checkpoint of category.checkpoints) {
        try {
          const result = await this.runCheckpoint(checkpoint);
          categoryResults.checkpoints.push(result);

          if (!result.passed) {
            this.findings.push({
              category: category.name,
              severity: checkpoint.severity,
              description: checkpoint.description,
              details: result.details,
              recommendation: this.getRecommendation(checkpoint.id),
            });
          }
        } catch (error) {
          console.error(`Error testing ${checkpoint.id}:`, error.message);
        }
      }

      this.results[categoryId] = categoryResults;
    }
  }

  async runCheckpoint(checkpoint) {
    console.log(`  Testing: ${checkpoint.description}`);

    // Simulate running the actual test
    // In a real implementation, these would be actual security tests
    const result = await this.simulateSecurityTest(checkpoint);

    const status = result.passed ? '‚úÖ' : '‚ùå';
    console.log(`    ${status} ${result.details}`);

    return {
      id: checkpoint.id,
      description: checkpoint.description,
      severity: checkpoint.severity,
      passed: result.passed,
      details: result.details,
    };
  }

  async simulateSecurityTest(checkpoint) {
    // Simulate different test results based on checkpoint ID
    switch (checkpoint.id) {
      case 'A01-01': // Authentication check
        return await this.checkAuthentication();
      case 'A01-02': // Authorization check
        return await this.checkAuthorization();
      case 'A02-01': // Password hashing
        return await this.checkPasswordHashing();
      case 'A03-01': // SQL injection
        return await this.checkSQLInjection();
      case 'A03-02': // Input validation
        return await this.checkInputValidation();
      case 'A05-01': // Security headers
        return await this.checkSecurityHeaders();
      default:
        return { passed: false, details: 'Test not implemented' };
    }
  }

  async checkAuthentication() {
    // Check if authentication middleware exists
    const authMiddlewarePath = path.join(
      process.cwd(),
      'middleware',
      'auth.js'
    );
    const exists = fs.existsSync(authMiddlewarePath);

    if (exists) {
      const content = fs.readFileSync(authMiddlewarePath, 'utf8');
      const hasTokenVerification =
        content.includes('jwt.verify') || content.includes('jsonwebtoken');

      return {
        passed: hasTokenVerification,
        details: hasTokenVerification
          ? 'JWT authentication middleware found'
          : 'Authentication middleware exists but no JWT verification found',
      };
    }

    return { passed: false, details: 'No authentication middleware found' };
  }

  async checkAuthorization() {
    // Check for role-based access control
    const authMiddlewarePath = path.join(
      process.cwd(),
      'middleware',
      'auth.js'
    );

    if (fs.existsSync(authMiddlewarePath)) {
      const content = fs.readFileSync(authMiddlewarePath, 'utf8');
      const hasRoleCheck =
        content.includes('role') || content.includes('permission');

      return {
        passed: hasRoleCheck,
        details: hasRoleCheck
          ? 'Role-based authorization found'
          : 'No role-based authorization implemented',
      };
    }

    return { passed: false, details: 'No authorization implementation found' };
  }

  async checkPasswordHashing() {
    // Check if bcrypt is used for password hashing
    const packageJsonPath = path.join(process.cwd(), 'package.json');

    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      const hasBcrypt =
        packageJson.dependencies?.bcrypt || packageJson.dependencies?.bcryptjs;

      return {
        passed: !!hasBcrypt,
        details: hasBcrypt
          ? 'bcrypt dependency found for password hashing'
          : 'No bcrypt dependency found - passwords may not be properly hashed',
      };
    }

    return { passed: false, details: 'package.json not found' };
  }

  async checkSQLInjection() {
    // Check if using ORM/ODM (Mongoose for MongoDB)
    const packageJsonPath = path.join(process.cwd(), 'package.json');

    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      const hasMongoose = packageJson.dependencies?.mongoose;
      const hasSequelize = packageJson.dependencies?.sequelize;

      if (hasMongoose || hasSequelize) {
        return {
          passed: true,
          details:
            'Using ORM/ODM which provides protection against injection attacks',
        };
      }
    }

    return {
      passed: false,
      details:
        'No ORM/ODM found - manual query construction may be vulnerable to injection',
    };
  }

  async checkInputValidation() {
    // Check for input validation libraries
    const packageJsonPath = path.join(process.cwd(), 'package.json');

    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      const hasJoi = packageJson.dependencies?.joi;
      const hasExpressValidator =
        packageJson.dependencies?.['express-validator'];
      const hasValidator = packageJson.dependencies?.validator;

      if (hasJoi || hasExpressValidator || hasValidator) {
        return {
          passed: true,
          details: 'Input validation library found',
        };
      }
    }

    return {
      passed: false,
      details: 'No input validation library found',
    };
  }

  async checkSecurityHeaders() {
    // Check for helmet.js
    const packageJsonPath = path.join(process.cwd(), 'package.json');

    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      const hasHelmet = packageJson.dependencies?.helmet;

      return {
        passed: !!hasHelmet,
        details: hasHelmet
          ? 'Helmet.js found for security headers'
          : 'No helmet.js found - security headers not configured',
      };
    }

    return { passed: false, details: 'package.json not found' };
  }

  async runAutomatedScans() {
    console.log('\nü§ñ Running automated security scans...');

    // This would integrate with actual scanning tools
    // For now, we'll simulate the results

    this.findings.push({
      category: 'Automated Scan',
      severity: 'medium',
      description: 'Outdated dependency found',
      details: 'lodash@4.17.15 has known vulnerabilities',
      recommendation: 'Update to lodash@4.17.21 or later',
    });
  }

  getRecommendation(checkpointId) {
    const recommendations = {
      'A01-01': 'Implement authentication middleware on all protected routes',
      'A01-02': 'Add role-based authorization checks',
      'A02-01': 'Use bcrypt for password hashing with minimum 12 rounds',
      'A03-01': 'Use ORM/ODM with parameterized queries',
      'A03-02': 'Implement input validation with joi or express-validator',
      'A05-01': 'Install and configure helmet.js for security headers',
    };

    return (
      recommendations[checkpointId] ||
      'Review security best practices for this area'
    );
  }

  generateReport() {
    console.log('\nüìä SECURITY ASSESSMENT REPORT');
    console.log('===============================\n');

    // Summary
    const totalFindings = this.findings.length;
    const criticalFindings = this.findings.filter(
      f => f.severity === 'critical'
    ).length;
    const highFindings = this.findings.filter(
      f => f.severity === 'high'
    ).length;
    const mediumFindings = this.findings.filter(
      f => f.severity === 'medium'
    ).length;

    console.log('üìà SUMMARY:');
    console.log(`Total Findings: ${totalFindings}`);
    console.log(`Critical: ${criticalFindings}`);
    console.log(`High: ${highFindings}`);
    console.log(`Medium: ${mediumFindings}`);

    // Detailed findings
    console.log('\nüîç DETAILED FINDINGS:\n');

    this.findings.forEach((finding, index) => {
      const severityIcon = {
        critical: 'üî¥',
        high: 'üü†',
        medium: 'üü°',
        low: 'üü¢',
      };

      console.log(
        `${index + 1}. ${severityIcon[finding.severity]} ${finding.description}`
      );
      console.log(`   Category: ${finding.category}`);
      console.log(`   Severity: ${finding.severity.toUpperCase()}`);
      console.log(`   Details: ${finding.details}`);
      console.log(`   Recommendation: ${finding.recommendation}\n`);
    });

    // Save report to file
    this.saveReportToFile();
  }

  saveReportToFile() {
    const reportData = {
      timestamp: new Date().toISOString(),
      summary: {
        totalFindings: this.findings.length,
        critical: this.findings.filter(f => f.severity === 'critical').length,
        high: this.findings.filter(f => f.severity === 'high').length,
        medium: this.findings.filter(f => f.severity === 'medium').length,
        low: this.findings.filter(f => f.severity === 'low').length,
      },
      findings: this.findings,
      results: this.results,
    };

    const reportsDir = path.join(process.cwd(), 'security', 'reports');
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }

    const filename = `security-report-${new Date()
      .toISOString()
      .slice(0, 10)}.json`;
    const filepath = path.join(reportsDir, filename);

    fs.writeFileSync(filepath, JSON.stringify(reportData, null, 2));
    console.log(`üìÑ Report saved to: ${filepath}`);
  }
}

module.exports = SecurityAssessor;
```

### **Paso 3: Ejecutar Assessment y An√°lisis (10 minutos)**

#### **3.1 Crear script principal de assessment**

```javascript
// security/run-assessment.js
const SecurityAssessor = require('./security-assessor');

async function runSecurityAssessment() {
  const assessor = new SecurityAssessor();

  try {
    await assessor.runFullAssessment();

    console.log('\n‚úÖ Security assessment completed successfully!');
    console.log(
      'üìÑ Check the security/reports/ directory for detailed reports.'
    );
  } catch (error) {
    console.error('‚ùå Security assessment failed:', error);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  runSecurityAssessment();
}

module.exports = { runSecurityAssessment };
```

#### **3.2 Ejecutar assessment completo**

```bash
# Ejecutar el script de security audit
./scripts/security-audit.sh

# Ejecutar assessment OWASP
node security/run-assessment.js

# Ejecutar npm audit
npm audit --audit-level=moderate

# Ejecutar Snyk scan (si est√° configurado)
snyk test
```

### **Paso 4: Remediation Plan (10 minutos)**

#### **4.1 Crear plan de remediaci√≥n**

````markdown
# SECURITY REMEDIATION PLAN

## Critical Priority Fixes

### 1. Password Hashing (A02-01)

- **Issue:** Weak password hashing
- **Solution:** Implement bcrypt with 12+ rounds
- **Timeline:** Immediate
- **Code:**

```javascript
const bcrypt = require('bcrypt');
const saltRounds = 12;

userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, saltRounds);
  next();
});
```
````

### 2. Input Validation (A03-02)

- **Issue:** Missing input validation
- **Solution:** Implement joi validation
- **Timeline:** 1 day
- **Code:**

```javascript
const Joi = require('joi');

const userValidationSchema = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().min(8).required(),
  nombre: Joi.string().min(2).max(50).required(),
});
```

## High Priority Fixes

### 3. Security Headers (A05-01)

- **Issue:** Missing security headers
- **Solution:** Install and configure helmet.js
- **Timeline:** 2 hours

### 4. Authentication Middleware (A01-01)

- **Issue:** Inconsistent auth checks
- **Solution:** Standardize auth middleware
- **Timeline:** 4 hours

## Medium Priority Fixes

### 5. Dependency Updates (A06-01)

- **Issue:** Outdated packages
- **Solution:** Update all dependencies
- **Timeline:** 1 day

````

---

## ‚úÖ Criterios de Validaci√≥n

### **Assessment Completeness**
- ‚úÖ OWASP Top 10 analysis completado
- ‚úÖ Automated scanning ejecutado
- ‚úÖ Manual testing realizado
- ‚úÖ Findings documentados apropiadamente
- ‚úÖ Remediation plan creado

### **Vulnerability Detection**
- ‚úÖ Authentication vulnerabilities identificadas
- ‚úÖ Input validation gaps encontrados
- ‚úÖ Security configuration issues detectados
- ‚úÖ Dependency vulnerabilities reportadas
- ‚úÖ Injection vulnerabilities evaluadas

### **Report Quality**
- ‚úÖ Findings categorizados por severidad
- ‚úÖ Remediation recommendations claras
- ‚úÖ Timeline para fixes establecido
- ‚úÖ Impact assessment incluido
- ‚úÖ Report guardado y accessible

---

## üß™ Pruebas de Validaci√≥n

### **1. Verificar que el assessment detecta vulnerabilidades**
```bash
# Introducir vulnerabilidad intencional y verificar detecci√≥n
# Ejemplo: comentar validaci√≥n de input
````

### **2. Verificar automated scanning**

```bash
# Ejecutar npm audit y verificar output
npm audit

# Verificar que ESLint security rules funcionan
npx eslint . --ext .js
```

### **3. Verificar generaci√≥n de reportes**

```bash
# Verificar que se genera el reporte JSON
ls -la security/reports/

# Verificar contenido del reporte
cat security/reports/security-report-*.json | jq .summary
```

---

## üìö Recursos Adicionales

### **Herramientas de Security Testing**

- [OWASP ZAP](https://www.zaproxy.org/) - Web application security testing
- [Snyk](https://snyk.io/) - Vulnerability scanning
- [npm audit](https://docs.npmjs.com/cli/v8/commands/npm-audit) - Dependency scanning
- [ESLint Security Plugin](https://github.com/nodesecurity/eslint-plugin-security) - Static analysis

### **Referencias OWASP**

- [OWASP Top 10 2021](https://owasp.org/Top10/)
- [OWASP Testing Guide](https://owasp.org/www-project-web-security-testing-guide/)
- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/)

---

## üéØ Entregables

1. **Security Assessment Report:** Reporte completo en JSON y texto
2. **Vulnerability Findings:** Lista detallada de vulnerabilidades
3. **Remediation Plan:** Plan priorizado de correcciones
4. **Automated Scripts:** Scripts para repeated assessments
5. **Documentation:** Gu√≠a para future security assessments

---

**¬°Assessment completado! Los estudiantes ahora pueden identificar y documentar vulnerabilidades de seguridad en aplicaciones web.**
